---
title: 7. riscv-mini新增乘法指令
icon: circle-plus
headerDepth: 3
description: 基于riscv-mini, 新增乘法指令，验证乘法功能。
tag: [riscv-mini, chisel]
---
## 目标
- 在riscv-mini的基础上新增一个指令-乘法指令。
- 编写程序，验证乘法功能。

## 内容
1. 修改数据通路，新增指令
`comb rs1,rs2,rd` R型，
combine 拼接，将rs1高16位和rs2低16位拼接成32位，保存到rd

2. 执行该指令，观察仿真波形，验证功能。

## 步骤
1. 新增模块
MDU(Multiplication Division Unit) 模块的功能是完成乘法与除法相关的运算，在这里我们暂时只实现有符号数乘法的功能。 

定义操作码，这里定义一个三位的无符号整数来表示操作。0表示不使用MDU的结果，1表示输出mul的结果。随后定义IO以及根据输入确定输出的结果。当mdu_op为MDU_MUL时将rs1与rs2看做有符号数进行乘法运算，随后将运算结果视为无符号数输出。 

添加BitPat 

修改控制单元以产生乘法指令执行时的控制信号。在映射中添加MUL指令，根据数据通路，MUL指令的执行后的PC数为PC+4、操作数为RS1和RS2、不使用立即数以及ALU、非分支指令、不需要冲刷流水线、不需要访存、在写回阶段将ALU流水寄存器中的 数值写会到寄存器文件当红在哪个、非CSR指令、非异常指令、MDU的控制信号为MDU_MUL 

对Control模块进行修改，以添加对于MDU模块控制信号的输出。首先修改Control模块的端口，添加mdu_op的输出。 

在Control模块中添加mdu_op的输出。 

对Datapath.scala进行修改添加MDU模块以及相关的线路。 

对于流水线，需要添加一个多路选择器，根据控制信号选择对于ALU流水线寄存器的写入数值，当没有执行乘法指令时写入的是alu输出的数据，否则写入的是mdu输出的数据。  

修改完成后在riscv-mni目录下执行 make 命令即可生成对应的Verilog文件 

随后执行 make verilator即可通过verilator生成用于仿真测试使用的可执行文件Vtile。 

编写如下汇编程序，其功能是通过 mul 指令计算3 * 11的并将计算结果存放至x7寄存器当中。 

通过riscv32-unknown-elf-gcc进⾏编译 

elf2hex⼯具来进⾏，在这个当中需要将elf⽂件转化为宽度为16字节的⼗六进制⽂件。 

译并通过VTile执行该代码，得到仿真过程中各个时钟周期的执行情况。通过观察仿真数据我们可以了解mul指令执行的结果。在PC=208为mul指令，从输出中可以看到其将0x21写回到x7寄存器当中，符合预期。 

在riscv-mini上运行自己编写的C程序。编写如下C程序，其功能是使用递归的方式计算阶乘。 

运行仿真程序，得到仿真的输出。按照RISC-V的规范约定，函数的返回值放置在a0(x10)寄存器中，因此只需要查看最后在该寄存器中写入的结果即可知道函数返回的结果。反正输出的节选如下，可以在最后出现的PC:000000264处观察到向x10寄存器中写入了0x00375f00，该数值即为10！= 3628800的十六进制 


